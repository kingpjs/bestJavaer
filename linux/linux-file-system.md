# Linux 文件系统

在 Linux 中，最直观、最可见的部分就是 `文件系统(file system)`。下面我们就来一起探讨一下关于 Linux 中国的文件系统，系统调用以及文件系统实现背后的原理和思想。这些思想中有一些来源于 MULTICS，现在已经被 Windows 等其他操作系统使用。Linux 的设计理念就是 `小的就是好的(Small is Beautiful)` 。虽然 Linux 只是使用了最简单的机制和少量的系统调用，但是 Linux 却提供了强大而优雅的文件系统。

## Linux 文件系统基本概念

Linux 在最初的设计是 MINIX1 文件系统，它只支持 14 字节的文件名，它的最大文件只支持到 64 MB。在 MINIX 1 之后的文件系统是 ext 文件系统。ext 系统相较于 MINIX 1 来说，在支持字节大小和文件大小上均有很大提升，但是 ext 的速度仍没有 MINIX 1 快，于是，ext 2 被开发出来，它能够支持长文件名和大文件，而且具有比 MINIX 1 更好的性能。这使他成为 Linux 的主要文件系统。只不过 Linux 会使用 `VFS` 曾支持多种文件系统。在 Linux 链接时，用户可以动态的将不同的文件系统挂载倒 VFS 上。

Linux 中的文件是一个任意长度的字节序列，Linux 中的文件可以包含任意信息，比如 ASCII 码、二进制文件和其他类型的文件是不加区分的。

为了方便起见，文件可以被组织在一个目录中，目录存储成文件的形式在很大程度上可以作为文件处理。目录可以有子目录，这样形成有层次的文件系统，Linux 系统下面的根目录是 `/` ，它通常包含了多个子目录。字符 `/` 还用于对目录名进行区分，例如 **/usr/cxuan** 表示的就是根目录下面的 usr 目录，其中有一个叫做 cxuan 的子目录。

下面我们介绍一下 Linux 系统根目录下面的目录名

* `/bin`，它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里
* `/boot`，启动包含引导加载程序的相关文件
* `/dev`，包含设备文件，终端文件，USB 或者连接到系统的任何设备
* `/etc`，配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动/停止单个应用程序的启动和关闭 shell 脚本
* `/home`，本地主要路径，所有用户用 home 目录存储个人信息
* `/lib`，系统库文件，包含支持位于 /bin 和 /sbin 下的二进制库文件
* `/lost+found`，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容
* `/media`，挂载可移动介质
* `/mnt`，挂载文件系统
* `/opt`，提供一个可选的应用程序安装目录
* `/proc`，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息
* `/root`，root 用户的主要目录文件夹
* `/sbin`，重要的二进制系统文件
* `/tmp`， 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除
* `/usr`，包含绝大多数用户都能访问的应用程序和文件
* `/var`，经常变化的文件，诸如日志文件或数据库等

在 Linux 中，有两种路径，一种是 `绝对路径(absolute path)` ，绝对路径告诉你从根目录下查找文件，绝对路径的缺点是太长而且不太方便。还有一种是 `相对路径(relative path)` ，相对路径所在的目录也叫做`工作目录(working directory)`。

如果 `/usr/local/books` 是工作目录，那么 shell 命令

```shell
cp books books-replica 
```

就表示的是相对路径，而

```shell
cp /usr/local/books/books /usr/local/books/books-replica
```

则表示的是绝对路径。

在 Linux 中经常出现一个用户使用另一个用户的文件或者使用文件树结构中的文件。两个用户共享同一个文件，这个文件位于某个用户的目录结构中，另一个用户需要使用这个文件时，必须通过绝对路径才能引用到他。如果绝对路径很长，那么每次输入起来会变的非常麻烦，所以 Linux 提供了一种 `链接(link)` 机制。

举个例子，下面是一个使用链接之前的图

<img src="https://s1.ax1x.com/2020/08/29/dTyinK.png" alt="21" border="0" style="zoom:50%;" >

以上所示，比如有两个工作账户 jianshe 和 cxuan，jianshe 想要使用 cxuan 账户下的 A 目录，那么它可能会输入 `/usr/cxuan/A` ，这是一种未使用链接之后的图。

使用链接后的示意如下

<img src="https://s1.ax1x.com/2020/08/29/dTy96x.png" alt="22" border="0" style="zoom:50%;" >

现在，jianshe 可以创建一个链接来使用 cxuan 下面的目录了。‘

当一个目录被创建出来后，有两个目录项也同时被创建出来，它们就是 `.` 和 `..` ，前者代表工作目录自身，后者代表该目录的父目录，也就是该目录所在的目录。这样一来，在 /usr/jianshe 中访问 cxuan 中的目录就是 `../cxuan/xxx`

Linux 文件系统不区分磁盘的，这是什么意思呢？一般来说，一个磁盘中的文件系统相互之间保持独立，如果一个文件系统目录想要访问另一个磁盘中的文件系统，在 Windows 中你可以像下面这样。

<img src="https://s1.ax1x.com/2020/08/29/dTyCX6.png" alt="23" border="0">

两个文件系统分别在不同的磁盘中，彼此保持独立。

而在 Linux 中，是支持`挂载`的，它允许一个磁盘挂在到另外一个磁盘上，那么上面的关系会变成下面这样

<img src="https://s1.ax1x.com/2020/08/29/dTsvtJ.png" alt="24" border="0">

挂在之后，两个文件系统就不再需要关心文件系统在哪个磁盘上了，两个文件系统彼此可见。

Linux 文件系统的另外一个特性是支持 `加锁(locking)`。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致`竞争条件(race condition)`。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。

POSIX 提供了一种灵活的、不同粒度级别的锁机制，允许一个进程使用一个不可分割的操作对一个字节或者整个文件进行加锁。加锁机制要求尝试加锁的进程指定其 **要加锁的文件，开始位置以及要加锁的字节**

Linux 系统提供了两种锁：**共享锁和互斥锁**。如果文件的一部分已经加上了共享锁，那么再加排他锁是不会成功的；如果文件系统的一部分已经被加了互斥锁，那么在互斥锁解除之前的任何加锁都不会成功。为了成功加锁、请求加锁的部分的所有字节都必须是可用的。

在加锁阶段，进程需要设计好加锁失败后的情况，也就是判断加锁失败后是否选择阻塞，如果选择阻塞式，那么当已经加锁的进程中的锁被删除时，这个进程会解除阻塞并替换锁。如果进程选择非阻塞式的，那么就不会替换这个锁，会立刻从系统调用中返回，标记状态码表示是否加锁成功，然后进程会选择下一个时间再次尝试。

加锁区域是可以重叠的。下面我们演示了三种不同条件的加锁区域。

<img src="https://s1.ax1x.com/2020/08/29/dTsjk4.png" alt="25" border="0">

如上图所示，A 的共享锁在第四字节到第八字节进行加锁

<img src="https://s1.ax1x.com/2020/08/29/dTsxh9.png" alt="26" border="0">

如上图所示，进程在 A 和 B 上同时加了共享锁，其中 6 - 8 字节是重叠锁

<img src="https://s1.ax1x.com/2020/08/29/dTySpR.png" alt="27" border="0">

如上图所示，进程 A 和 B 和 C 同时加了共享锁，那么第六字节和第七字节是共享锁。

如果此时一个进程尝试在第 6 个字节处加锁，此时会设置失败并阻塞，由于该区域被 A B C 同时加锁，那么只有等到 A B C 都释放锁后，进程才能加锁成功。

## Linux 文件系统调用

许多系统调用都会和文件与文件系统有关。我们首先先看一下对单个文件的系统调用，然后再来看一下对整个目录和文件的系统调用。

为了创建一个新的文件，会使用到 `creat` 方法，注意没有 `e`。

>这里说一个小插曲，曾经有人问 UNIX 创始人 Ken Thompson，如果有机会重新写 UNIX ，你会怎么办，他回答自己要把 creat 改成 create ，哈哈哈哈。

这个系统调用的两个参数是文件名和保护模式

```shell
fd = creat("aaa",mode);
```

这段命令会创建一个名为 aaa 的文件，并根据 mode 设置文件的保护位。这些位决定了哪个用户可能访问文件、如何访问。

creat 系统调用不仅仅创建了一个名为 aaa 的文件，还会打开这个文件。为了允许后续的系统调用访问这个文件，这个 creat 系统调用会返回一个 `非负整数`， 这个就叫做 `文件描述符(file descriptor)`，也就是上面的 fd。

如果在已经存在的文件上调用了 creat 系统调用，那么该文件中的内容会被清除，从 0 开始。通过设置合适的参数，`open` 系统调用也能够创建文件。

下面让我们看一看主要的系统调用，如下表所示

| 系统调用                             | 描述                     |
| ------------------------------------ | ------------------------ |
| fd = creat(name,mode)                | 一种创建一个新文件的方式 |
| fd = open(file, ...)                 | 打开文件读、写或者读写   |
| s = close(fd)                        | 关闭一个打开的文件       |
| n = read(fd, buffer, nbytes)         | 从文件中向缓存中读入数据 |
| n = write(fd, buffer, nbytes)        | 从缓存中向文件中写入数据 |
| position = lseek(fd, offset, whence) | 移动文件指针             |
| s = stat(name, &buf)                 | 获取文件信息             |
| s = fstat(fd, &buf)                  | 获取文件信息             |
| s = pipe(&fd[0])                     | 创建一个管道             |
| s = fcntl(fd,...)                    | 文件加锁等其他操作       |

为了对一个文件进行读写的前提是先需要打开文件，必须使用 creat 或者 open 打开，参数是打开文件的方式，是只读、可读写还是只写。open 系统调用也会返回文件描述符。打开文件后，需要使用 `close` 系统调用进行关闭。close 和 open 返回的 fd 总是未被使用的最小数量。

>什么是文件描述符？文件描述符就是一个数字，这个数字标示了计算机操作系统中打开的文件。它描述了数据资源，以及访问资源的方式。

当程序要求打开一个文件时，内核会进行如下操作

* 授予访问权限
* 在`全局文件表(global file table)`中创建一个`条目(entry)`
* 向软件提供条目的位置

文件描述符由唯一的非负整数组成，系统上每个打开的文件至少存在一个文件描述符。文件描述符最初在 Unix 中使用，并且被包括 Linux，macOS 和 BSD 在内的现代操作系统所使用。

当一个进程成功访问一个打开的文件时，内核会返回一个文件描述符，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如下图所示

<img src="https://s1.ax1x.com/2020/08/29/dTyp11.png" alt="28" border="0">

默认情况下，前三个文件描述符为 `STDIN(标准输入)`、`STDOUT(标准输出)`、`STDERR(标准错误)`。

标准输入的文件描述符是 0 ，在终端中，默认为用户的键盘输入

标准输出的文件描述符是 1 ，在终端中，默认为用户的屏幕

与错误有关的默认数据流是 2，在终端中，默认为用户的屏幕。

在简单聊了一下文件描述符后，我们继续回到文件系统调用的探讨。

在文件系统调用中，开销最大的就是 read 和 write 了。read 和 write 都有三个参数

* `文件描述符`：告诉需要对哪一个打开文件进行读取和写入
* `缓冲区地址`：告诉数据需要从哪里读取和写入哪里
* `统计`：告诉需要传输多少字节

这就是所有的参数了，这个设计非常简单轻巧。

虽然几乎所有程序都按顺序读取和写入文件，但是某些程序需要能够随机访问文件的任何部分。与每个文件相关联的是一个指针，该指针指示文件中的当前位置。顺序读取（或写入）时，它通常指向要读取（写入）的下一个字节。如果指针在读取 1024 个字节之前位于 4096 的位置，则它将在成功读取系统调用后自动移至 5120 的位置。

`Lseek` 系统调用会更改指针位置的值，以便后续对 read 或 write 的调用可以在文件中的任何位置开始，甚至可以超出文件末尾。

>lseek = Lseek ，段首大写。

lseek 避免叫做 seek 的原因就是 seek 已经在之前 16 位的计算机上用于搜素功能了。

`Lseek` 有三个参数：第一个是文件的文件描述符，第二个是文件的位置；第三个告诉文件位置是相对于文件的开头，当前位置还是文件的结尾

```c
lseek(int fildes, off_t offset, int whence);
```

lseek 的返回值是更改文件指针后文件中的绝对位置。lseek 是唯一从来不会造成真正磁盘查找的系统调用，它只是更新当前的文件位置，这个文件位置就是内存中的数字。

对于每个文件，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 `stat` 系统调用看到这些信息。第一个参数就是文件名，第二个是指向要放置请求信息结构的指针。这些结构的属性如下图所示。

| 存储文件的设备           |
| ------------------------ |
| 存储文件的设备           |
| i-node 编号              |
| 文件模式(包括保护位信息) |
| 文件链接的数量           |
| 文件所有者标识           |
| 文件所属的组             |
| 文件大小(字节)           |
| 创建时间                 |
| 最后一个修改/访问时间    |

`fstat` 调用和 `stat` 相同，只有一点区别，fstat 可以对打开文件进行操作，而 stat 只能对路径进行操作。

`pipe` 文件系统调用被用来创建 shell 管道。它会创建一系列的`伪文件`，来缓冲和管道组件之间的数据，并且返回读取或者写入缓冲区的文件描述符。在管道中，像是如下操作

```shell
sort <in | head –40
```

sort 进程将会输出到文件描述符1，也就是标准输出，写入管道中，而 head 进程将从管道中读入。在这种方式中，sort 只是从文件描述符 0 中读取并写入到文件描述符 1 （管道）中，甚至不知道它们已经被重定向了。如果没有重定向的话，sort 会自动的从键盘读入并输出到屏幕中。

最后一个系统调用是 `fcntl`，它用来锁定和解锁文件，应用共享锁和互斥锁，或者是执行一些文件相关的其他操作。

现在我们来关心一下和整体目录和文件系统相关的系统调用，而不是把精力放在单个的文件上，下面列出了这些系统调用，我们一起来看一下。

| 系统调用                  | 描述                   |
| ------------------------- | ---------------------- |
| s = mkdir(path,mode)      | 创建一个新的目录       |
| s = rmdir(path)           | 移除一个目录           |
| s = link(oldpath,newpath) | 创建指向已有文件的链接 |
| s = unlink(path)          | 取消文件的链接         |
| s = chdir(path)           | 改变工作目录           |
| dir = opendir(path)       | 打开一个目录读取       |
| s = closedir(dir)         | 关闭一个目录           |
| dirent = readdir(dir)     | 读取一个目录项         |
| rewinddir(dir)            | 回转目录使其在此使用   |

可以使用 mkdir 和 rmdir 创建和删除目录。但是需要注意，只有目录为空时才可以删除。

创建一个指向已有文件的链接时会创建一个`目录项(directory entry)`。系统调用 link 来创建链接，oldpath 代表已有的路径，newpath 代表需要链接的路径，使用 `unlink` 可以删除目录项。当文件的最后一个链接被删除时，这个文件会被自动删除。

使用 `chdir` 系统调用可以改变工作目录。

最后四个系统调用是用于读取目录的。和普通文件类似，他们可以被打开、关闭和读取。每次调用 `readdir` 都会以固定的格式返回一个目录项。用户不能对目录执行写操作，但是可以使用 creat 或者 link 在文件夹中创建一个目录，或使用 unlink 删除一个目录。用户不能在目录中查找某个特定文件，但是可以使用 `rewindir` 作用于一个打开的目录，使他能在此从头开始读取。

















