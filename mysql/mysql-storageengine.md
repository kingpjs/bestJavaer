# MySQL 存储引擎

### 存储引擎概述

数据库最核心的一点就是用来存储数据，数据存储就避免不了和磁盘打交道。那么数据以哪种方式进行存储，如何存储是存储的关键所在。所以存储引擎就相当于是数据存储的发动机，来驱动数据在磁盘层面进行存储。

MySQL 的架构可以按照三层模式来理解

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132644352-762193374.png)

存储引擎也是 MySQL 的组建，它是一种软件，它所能做的和支持的功能主要有

* 并发
* 支持事务
* 完整性约束
* 物理存储
* 支持索引
* 性能帮助

MySQL 默认支持多种存储引擎，来适用不同数据库应用，用户可以根据需要选择合适的存储引擎，下面是 MySQL 支持的存储引擎

* MyISAM
* InnoDB
* BDB
* MEMORY
* MERGE
* EXAMPLE
* NDB Cluster
* ARCHIVE
* CSV
* BLACKHOLE
* FEDERATED

默认情况下，如果创建表不指定存储引擎，会使用默认的存储引擎，如果要修改默认的存储引擎，那么就可以在参数文件中设置 `default-table-type`，能够查看当前的存储引擎

```mysql
show variables like 'table_type';
```

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132653321-1448731651.png)

奇怪，为什么没有了呢？网上求证一下，在 5.5.3 取消了这个参数

可以通过下面两种方法查询当前数据库支持的存储引擎

```mysql
show engines \g
```

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132701846-916881020.png)

在创建新表的时候，可以通过增加 `ENGINE` 关键字设置新建表的存储引擎。

```mysql
create table cxuan002(id int(10),name varchar(20)) engine = MyISAM;
```

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132710498-2129087271.png)

上图我们指定了 `MyISAM` 的存储引擎。

如果你不知道表的存储引擎怎么办？你可以通过 `show create table` 来查看

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132718513-1446260200.png)

如果不指定存储引擎的话，从MySQL 5.1 版本之后，MySQL 的默认内置存储引擎已经是 InnoDB了。建一张表看一下

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132728457-1031120122.png)

如上图所示，我们没有指定默认的存储引擎，下面查看一下表

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132739877-1042995853.png)

可以看到，默认的存储引擎是 `InnoDB`。

如果你的存储引擎想要更换，可以使用 

```mysql
alter table cxuan003 engine = myisam;
```

来更换，更换完成后回显示 **0 rows affected** ，但其实已经操作成功

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132751752-701092827.png)

我们使用 `show create table` 查看一下表的 sql 就知道

![](https://img2020.cnblogs.com/blog/1515111/202007/1515111-20200706132758050-1708717669.png)

### 存储引擎特性

下面会介绍几个常用的存储引擎以及它的基本特性，这些存储引擎是 **MyISAM、InnoDB、MEMORY 和 MERGE ** 

#### MyISAM

在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是

* 不支持`事务`操作，ACID 的特性也就不存在了，这一设计是为了性能和效率考虑的。

* 不支持`外键`操作，如果强行增加外键，MySQL 不会报错，只不过外键不起作用。

* MyISAM 默认的锁粒度是`表级锁`，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。

* MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是 `.frm(存储表定义)`、`.MYD(MYData,存储数据)`、`MYI(MyIndex,存储索引)`。这里需要特别注意的是 MyISAM 只缓存`索引文件`，并不缓存数据文件。

* MyISAM 支持的索引类型有 `全局索引(Full-Text)`、`B-Tree 索引`、`R-Tree 索引`

  Full-Text 索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。

  B-Tree 索引：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点

  R-Tree索引：它的存储方式和 B-Tree 索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE 的优势在于范围查找。

* 数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。

* 增删改查性能方面：SELECT 性能较高，适用于查询较多的情况

#### InnoDB

自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是

* 支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是`可重复读(repetable-read)`、通过`MVCC（并发版本控制）`来实现的。能够解决`脏读`和`不可重复读`的问题。
* InnoDB 支持外键操作。
* InnoDB 默认的锁粒度`行级锁`，并发性能比较好，会发生死锁的情况。
* 和 MyISAM 一样的是，InnoDB 存储引擎也有 `.frm文件存储表结构` 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。
* InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。
* InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。
* 增删改查性能方面，果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。

#### MEMORY

MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表实际只对应一个磁盘文件，格式是 `.frm`。 MEMORY 类型的表访问速度很快，因为其数据是存放在内存中。默认使用 `HASH 索引`。

#### MERGE

MERGE 存储引擎是一组 MyISAM 表的组合，MERGE 表本身没有数据，对 MERGE 类型的表进行查询、更新、删除的操作，实际上是对内部的 MyISAM 表进行的。MERGE 表在磁盘上保留两个文件，一个是 `.frm` 文件存储表定义、一个是 `.MRG` 文件存储 MERGE 表的组成等。

### 选择合适的存储引擎

在实际开发过程中，我们往往会根据应用特点选择合适的存储引擎。

* MyISAM：如果应用程序通常以检索为主，只有少量的插入、更新和删除操作，并且对事物的完整性、并发程度不是很高的话，通常建议选择 MyISAM 存储引擎。
* InnoDB：如果使用到外键、需要并发程度较高，数据一致性要求较高，那么通常选择 InnoDB 引擎，一般互联网大厂对并发和数据完整性要求较高，所以一般都使用 InnoDB 存储引擎。
* MEMORY：MEMORY 存储引擎将所有数据保存在内存中，在需要快速定位下能够提供及其迅速的访问。MEMORY 通常用于更新不太频繁的小表，用于快速访问取得结果。
* MERGE：MERGE 的内部是使用 MyISAM 表，MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同的表分布在多个磁盘上， 可以有效地改善 MERGE 表的访问效率。